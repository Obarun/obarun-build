#!/usr/bin/bash
#
# Functions file for obarun-build package
#
# Authors:
# Eric Vidal <eric@obarun.org>
#
# Copyright (C) 2016 Eric Vidal <eric@obarun.org>
#
# "THE BEERWARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal http://obarun.org
#
# This script is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 
TEMPLATES="${TEMPLATES:-/usr/share/obarun/obarun-build/templates}"
WORKDIR="container"
WORKCONF="config"
LXC_CONF="/var/lib/lxc/"

clean_install(){
	
	echo_display " Cleaning up"
	
	if [[ -n "${named}" ]]; then
		if [[ -d "${TARGET}/${named}" ]]; then
			delete_container "${TARGET}" "${named}"
		fi
	fi
	
	echo_valid " Restore your shell options"
	shellopts_restore
	
	exit
}

usage(){
	cat << EOF
	
${bold}Usage: ${0} [General options] [Sub options] name

e.g obarun-build Create create container
    obarun-build C c container
    obarun-build B b cups
    obarun-build M container
    obarun-build M network${reset}
    
${bold}General options :${reset}
    C, Create : create a container
    B, Build : build a package onto a container
    M, Manage : open an interactive shell to manage a named container

${bold}Sub options :${reset}
    for Create :
        c, create : create a container
    for Build :
        b, build : build a package onto a container
        r, remake : build a package onto an archived container
    for Manage :
        n, network : manage the bridge
EOF
	exit 0
}

# ${1} command to pass
# ${2} arguments to pass. Can be empty
# functions return 0 on success, 1 on other case
lxc_command_parse(){
	local command loop_ ret
	local -a parse_opt rest_opt
	
	command="${1}"
	parse_opt=( "${@}" )

	
	# check if lxc-${command} exist
	check_lxc_command "${command}"

	if (( ! $? )); then
		if [[ "${command}" == @(ls|autostart|checkconfig|top|usernsexec) ]]; then
			rest_opt=( "${parse_opt[@]:1}" )
			"lxc-${command}" "${rest_opt[@]}" || return 1 #die " Aborting command : lxc-${command} ${parse_opt[@]:1}"
		else
			if [[ -z "${parse_opt[1]}" ]]; then
				echo_error " name must not be empty"
				return 1
			fi
			# if the container was not stopped before exiting of it
			# the command stop may take time, just warm them
			if [[ "${command}" == "stop" ]]; then
				echo_notvalid " Trying to shutdown ${named}, this may take time..."
			fi
			rest_opt=( "${parse_opt[@]:2}" )
			"lxc-${command}" -n "${parse_opt[1]}" "${rest_opt[@]}" || return 1 #die " Aborting command : lxc-${command} -n ${parse_opt[1]} ${rest_opt[@]}"
		fi
	else
		die " lxc-${command} doesn't exist" "clean_install"
	fi
		
	return 0
}

# ${1} name of the container to create
# ${@} arguments to pass. Can be empty
create(){
	local file named
	local -a file_list _args
	
	mapfile -t file_list < <(ls --group-directories-first ${TEMPLATES}/*)
	
	named="${1}"
	_args=( "${@}" )
	_args=( "${_args[@]:1}" )

	# check if container directory exist
	# if yes then exit container exit
	check_dir "${TARGET}/${named}"
	if (( ! $? )); then
		echo_info " Container already exit, do you want overwrite it? [y|n] :"
		reply_answer
		if (( $? )); then
			die " Exiting"
		else
			delete_container "${TARGET}" "${named}"
		fi
	fi
	
	# create the templates directory on $TARGET
	echo_display " Create ${TARGET}/${named}/${WORKCONF}"
	mkdir -p "${TARGET}/${named}/${WORKCONF}" || die " Impossible to create directory ${TARGET}/${named}/${WORKCONF}" "clean_install"
	
	# copy configuration file to $TARGET
	for file in "${file_list[@]}"; do
		file=${file##*/}
		echo_display " Copy ${file} templates file to ${TARGET}/${named}/${WORKCONF}"
		cp "${TEMPLATES}/${file}" "${TARGET}/${named}/${WORKCONF}" || die " Impossible to copy ${file}" "clean_install"
	done
	
	# now we have to correct place to find configuration file to create and configure the container
	# so, exporting the good one
	export create_conf="${TARGET}/${named}/${WORKCONF}/create.conf"
	export named="${named}"
	export WORKDIR="${WORKDIR}"
	export WORKCONF="${WORKCONF}"
	check_var(){
		echo create_conf :: "${create_conf}"
		echo named :: "${named}"
		echo WORKDIR :: "${WORKDIR}"
		echo WORKCONF :: "${WORKCONF}"
	}
	#check_var
	lxc_command_parse "create" "${named}" -t "${TARGET}/${named}/${WORKCONF}/create" "${_args[@]}" || die " Impossible to create the container" "clean_install"
	
}

# ${1} name of the container
# ${@} arguments to pass. Can be empty
build(){
	local named
	local -a _args
	named="${1}"
	_args=( "${@}" )
	_args=( "${_args[@]:1}" )
	
	clean_build(){
		lxc_command_parse "stop" "${named}-${named_version}" -k
		lxc_command_parse "destroy" "${named}-${named_version}"
		rm -rf "${TARGET}/${named}-${named_version}"
		clean_install
	}
	
	# check if sources variables is set
	if [[ -z "${SOURCES}" ]]; then
		die " Aborting : sources variables on /etc/obarun/build.conf is not set" "clean_build"
	fi
	
	# be sure that $named exist on $SOURCES directory
	check_dir "${SOURCES}/${named}"
	if (( $? )); then
		die " ${named} do not exist on ${SOURCES} directory" "clean_build"
	fi
	
	# be sure that a PKGBUILD file exit on $SOURCES/$named
	search_in_dir "${SOURCES}" "${named}" "PKGBUILD"
	if (( $? )); then
		die " Aborting : a PKGBUILD file must at least exist into ${SOURCES} directory" "clean_build"
	fi
	
	# retrieve pkgver and pkgrel to implemente them onto the name
	# sanitize the pkgver pkgrel first
	unset pkgver pkgrel
	
	source "${SOURCES}/${named}/PKGBUILD"
	
	_pkgver="$pkgver"
	_pkgrel="$pkgrel"
	named_version="${_pkgver}-${_pkgrel}"
	
	# be sure that the named container doesn't exist
	lxc-ls | grep "${named}-${named_version}" &>/dev/null
	if (( ! $? )); then
		echo_error " Container already exist, please choose another name"
	fi
	
	# create the container
	create "${named}-${named_version}" "${_args[@]}"
	
	# copy $SOURCES/$named files onto the container
	cp -ra "${SOURCES}/${named}" "${TARGET}/${named}-${named_version}/${WORKDIR}/rootfs/tmp/${named}-${named_version}" || die " Impossible to copy file from ${SOURCES}/${named}-${named_version}" "clean_build"


	# remove existing package and src, pkg directories
	rm -f "${TARGET}/${named}-${named_version}/${WORKDIR}/rootfs/tmp/${named}"/*.pkg.* &>/dev/null
	rm -rf "${TARGET}/${named}-${named_version}/${WORKDIR}/rootfs/tmp/${named}"/{src,pkg} &>/dev/null
	
	# start the container
	lxc_command_parse "start" "${named}-${named_version}" || die " Aborting : impossible to start the container ${named}-${named_version}" "clean_build"
	
	# give a good permissions at the tmp/$named onto the container
	lxc_command_parse "attach" "${named}-${named_version}" --clear-env -v named="${named}-${named_version}" -v newuser="${NEWUSER}" -- bash -c 'echo "${newuser}" "ALL=(ALL)" NOPASSWD: ALL >> /etc/sudoers'
	lxc_command_parse "attach" "${named}-${named_version}" --clear-env -v named="${named}-${named_version}" -v newuser="${NEWUSER}" -- bash -c 'chown -R "${newuser}":users /tmp/"${named}"'
	
	# build the package
	lxc_command_parse "attach" "${named}-${named_version}" --clear-env -v named="${named}-${named_version}" -v newuser="${NEWUSER}" -- bash -c 'cd /tmp/"${named}"; su "${newuser}"  -c "updpkgsums; makepkg -Cs --noconfirm"' || die " Something wrong happen at building the package" "clean_build"
	
	# copy the resulting package on the right place
	check_dir "${SAVE_PKG}/${named}/${named_version}"
	if (( $? )); then
		mkdir -p "${SAVE_PKG}/${named}/${named_version}"
	fi
	cp -f "${TARGET}/${named}-${named_version}/${WORKDIR}/rootfs/tmp/${named}-${named_version}"/*.pkg.tar.* "${SAVE_PKG}/${named}/${named_version}" || echo_info " WARNING : the resulting package can be copied to ${SAVE_PKG}/${named}/${named_version}" "clean_install"
	
	# stop the container
	lxc_command_parse "stop" "${named}-${named_version}" -k || die " Impossible to stop the container" "clean_build"
	
	echo_display " Would you like to destroy the container? [y|n]"
	reply_answer
	if (( ! $? )); then
		lxc_command_parse "destroy" "${named}-${named_version}" && rm -rf "${TARGET}/${named}-${named_version}"
	fi
}

remake(){
	echo_bold " Features not implemented"
}

################################################################################################################
##																											  ##	
##										sub_functions														  ##
##																											  ##
################################################################################################################

# ${1} command to check
# return 0 on success,1 for fail
check_lxc_command(){
	local loop_ command ret
	command="${1}"

	for loop_ in $(ls /bin/|grep lxc-|sed 's:*::'); do
		if [[ lxc-"${command}" == "${loop_}" ]]; then
			return 0
		fi
	done
	
	return 1
		
	unset ret loop_ command
}

# ${1} path to the container
# ${2} name of the container
delete_container(){
	local _named _path stats
	
	_path="${1}"
	_named="${2}"
	
	check_dir "${LXC_CONF}/${_named}"
	if (( ! $? )); then
		stat=$(lxc_command_parse "info" "${_named}" "-s" | awk -F':' '{ print $2 }' | sed 's: ::g' )
		if [[ "${stat}" == "RUNNING" ]];then
			lxc_command_parse "stop" "${_named}" "-k"
		fi
		lxc_command_parse "destroy" "${_named}"
	fi
	
	rm -rf "${_path}/${_named}" || die " Impossible to remove ${TARGET}/${named}"
	
	unset _named _path
}

# ${1} name of the container to manage.
# ${2} come from switch or not : 0 for not
# this is avoid to display the first menu
manage(){
	local ans ans_command ans_full parse_ans named _sw sw empty_named pick container_exist ret
	local -a container_list
	named="${1}"
	container_list=( $(lxc-ls -1 2>/dev/null) )
	
	
	check_existing_container(){
			select pick in "${container_list[@]}"; do
				case "$pick" in
					*)if check_elements "$pick" "${container_list[@]}"; then
						named="${pick}"
						break
					else 
						echo_retry " Invalid number, retry :"
					fi
				esac
			done
	}
	
	if [[ -z "${named}" ]]; then
		echo_info " name must not be empty"
		if [[ -n "${container_list[@]}" ]]; then
			echo_info " please pick one on the following list"
			check_existing_container
		else
			die
		fi
	else
		for container_exist in "${container_list[@]}"; do
			if [[ "${named}" == "${container_exist}" ]]; then
				ret=0
				break
			else
				ret=1
			fi
		done
		if (( $ret )); then
			echo_info " ${named} doesn't exist"
			echo_info " please pick one on the following list"
			check_existing_container
		fi
		unset ret
	fi
	
	_sw="${2}"
	
	# display or not the following line
	if [[ "${_sw}" == 0 ]] || [[ -z "${_sw}" ]]; then
		printf "\n" >&1
		printf " Type help to see option\n" >&1
		printf " Type quit for exit\n" >&1
	fi
	
	while true; do
		echo ""
		
		read -p "Manage ${named} > " ans 
		
		parse_ans=( ${ans[@]} )
		ans_command=( ${parse_ans[0]} )
		ans_full=( ${parse_ans[@]:1} )
		
		check_var(){
			echo ans="${ans[@]}"
			echo parse_ans="${parse_ans[@]}"
			echo ans_command="${ans_command}"
			echo ans_full="${ans_full[@]}"
		}
		#check_var
		
		case "${ans_command}" in
			network)
				manage_network
				;;
			switch)
				named="${parse_ans[1]}"
				sw=1
				break
				;;
			help)
				manage_help
				;;
			quit) 
				exit
				;;
			*)
				# check if lxc-${command} exist
				check_lxc_command "${ans_command}"
							
				if (( $? )); then
					printf " Incorrect command, try help\n" >&1
				else
					if [[ "${ans_command}" == @(ls|autostart|checkconfig|top|usernsexec) ]]; then
						# eval here can be dangerous, need to find a turn around
						eval lxc-"${ans_command}" "${ans_full[@]}"
						(( ! $? )) || echo_info "Warning : the command failed, see above"
					else
						# eval here can be dangerous, need to find a turn around
						eval lxc-"${ans_command}" -n "${named}" "${ans_full[@]}"
						# don't stop the script if the command fail, but warm it
						(( ! $? )) || echo_info "Warning : the command failed, see above"
					fi
				fi
		esac
	done
	if (( $sw )); then
		manage "${named}" "1"
	fi
}

manage_help(){
	
	printf "%-15s %-15s\n" "attach" "start a process inside a running container" >&1
	printf "%-15s %-15s\n" "autostart" "start/stop/kill auto-started containers" >&1
	printf "%-15s %-15s\n" "cgroup" "start a process inside a running container" >&1
	printf "%-15s %-15s\n" "checkconfig" "start a process inside a running container" >&1
	printf "%-15s %-15s\n" "checkpoint" "checkpoint a container" >&1
	printf "%-15s %-15s\n" "config" "query LXC system configuration" >&1
	printf "%-15s %-15s\n" "console" "launch a console for the specified container" >&1
	printf "%-15s %-15s\n" "copy" "copy an existing container" >&1
	printf "%-15s %-15s\n" "create" "creates a container" >&1
	printf "%-15s %-15s\n" "destroy" "destroy a container" >&1
	printf "%-15s %-15s\n" "device" "manage devices of running containers" >&1
	printf "%-15s %-15s\n" "execute" "run an application inside a container" >&1
	printf "%-15s %-15s\n" "freeze" "freeze all the container's processes" >&1
	printf "%-15s %-15s\n" "info" "query information about a container" >&1
	printf "%-15s %-15s\n" "ls" "list the containers existing on the system" >&1
	printf "%-15s %-15s\n" "monitor" "monitor the container state" >&1
	printf "%-15s %-15s\n" "network" "create/start/stop/destroy the bridge" >&1
	printf "%-15s %-15s\n" "quit" "exit from this menu" >&1
	printf "%-15s %-15s\n" "snapshot" "snapshot an existing container" >&1
	printf "%-15s %-15s\n" "start" "start a container" >&1
	printf "%-15s %-15s\n" "stop" "stop a container" >&1
	printf "%-15s %-15s\n" "switch" "manage the named container" >&1
	printf "%-15s %-15s\n" "top" "monitor container statistics" >&1
	printf "%-15s %-15s\n" "unfreeze" "thaw all the container's processes" >&1
	printf "%-15s %-15s\n" "unshare" "run a task in a new set of namespaces" >&1
	printf "%-15s %-15s\n" "usernsexec" "run a task as root in a new user namespace" >&1
	printf "%-15s %-15s\n" "wait" "wait for a specific container state" >&1
	printf "%-15s %-15s\n" "" >&1
	printf "%-15s %-15s\n" "" >&1
	printf "%-15s %-15s\n" "If you want more information about a command,"
	printf "%-15s %-15s\n" "type e.g start --help"
	
}

manage_network(){
	local ans
	
	printf "\n" >&1
	printf " Type help to see option to control the bridge\n" >&1
	printf " Type quit for exit\n" >&1
	printf "\n" >&1
	
	while true; do
		read -e -p "Manage network > " ans
		case "${ans}" in
			create)
				network_create
				;;
			start)
				network_start
				;;
			stop)
				network_stop
				;;
			destroy)
				network_destroy
				;;
			show)
				network_show
				;;
			help)
				manage_network_help
				;;
			quit)
				break
				;;
			*)
				printf " Incorrect command, try help\n" >&1
				;;
		esac
	done
}

manage_network_help(){
	printf "%-15s %-15s\n" "create" "create the bridge and start it" >&1
	printf "%-15s %-15s\n" "destroy" "destroy the bridge" >&1
	printf "%-15s %-15s\n" "start" "active the bridge" >&1
	printf "%-15s %-15s\n" "stop" "disactive the bridge" >&1
	printf "%-15s %-15s\n" "show" "show network" >&1
}

network_destroy(){
	ip link set "${HOST_INTERFACE}" nomaster
	ip link set "${BRIDGE_INTERFACE}" down
	ip link delete "${BRIDGE_INTERFACE}" type bridge
	ip route add default via "${ROUTER_ADDR}"
}

network_create(){
	
	# check if the bridge exist
	# if not, create it
	ip link show type bridge | grep ${BRIDGE_INTERFACE} &>/dev/null
	if (( $? )); then
		ip link add name "${BRIDGE_INTERFACE}" address 00:16:3e:$(openssl rand -hex 3| sed 's/\(..\)/\1:/g; s/.$//') type bridge
		ip link set "${BRIDGE_INTERFACE}" up
		ip addr add "${BRIDGE_ADDR}" dev "${BRIDGE_INTERFACE}" 
		ip link set "${HOST_INTERFACE}" master "${BRIDGE_INTERFACE}" 
	fi
	if ! $(grep -q "POSTROUTING -o ${HOST_INTERFACE} -j" /etc/iptables/iptables.rules 2>/dev/null); then
	
		iptables -t nat -A POSTROUTING -o "${HOST_INTERFACE}" -j MASQUERADE
	
		echo_info "-t nat -A POSTROUTING -o "${HOST_INTERFACE}" -j MASQUERADE" 
		echo_info "was added to your /etc/iptables/iptables.rules"
	fi
}
network_show(){
	ip link show
}
network_start(){
	ip link set "${HOST_INTERFACE}" master "${BRIDGE_INTERFACE}"
}

network_stop(){
	ip link set "${HOST_INTERFACE}" nomaster
}
