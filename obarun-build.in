#!@BINDIR@/bash
# Copyright (c) 2015-2017 Eric Vidal <eric@obarun.org>
# All rights reserved.
# 
# This file is part of Obarun. It is subject to the license terms in
# the LICENSE file found in the top-level directory of this
# distribution and at https://github.com/Obarun/obarun-build/LICENSE
# This file may not be copied, modified, propagated, or distributed
# except according to the terms contained in the LICENSE file.

##		Check is the functions file exits

sourcing(){
	
	local list
	
	for list in /etc/obarun/build.conf /usr/lib/obarun/{util.sh,build.sh}; do
		if [[ -f "${list}" ]]; then
			source "${list}"
		else
			out_error "Missing file : ${list}"
			exit	
		fi
	done
	
	unset list
}
sourcing

shellopts_save
shellopts_set_unset "extglob" 0

##		Clean before exit

trap "clean_install" ERR QUIT KILL STOP INT TERM 

##		Must be run with root privilegies 

(( EUID == 0 )) || die " ${bred}You must be run this script with root privilegies"

##		Let's go

##		Update package or not

main_update(){
	out_action "Do you want to update obarun-build package? [y|n]"

	reply_answer

	if (( ! $? )); then
		pac_update "obarun-build" "/var/lib/obarun/obarun-build" "$GIT_ADDR" || die " Impossible to update" "clean_install"
		sourcing
	else
		out_notvalid "Some functionalities will cannot working properly without updating"
		out_info "Press enter to continue"
		read enter
	fi
}

if [[ "$UPDATE" == "yes" ]]; then
	main_update
fi

if [[ -z "${1}" || -z "${2}" ]] && [[ "${1}" != @(M|Manage) ]]; then
	usage
	exit 1
fi

parse_command=( "${@}" )
main_opt=( "${parse_command[0]}" )
sub_opt=( "${parse_command[1]}" )
named=( "${parse_command[2]}" )
named_in_opt=( "${parse_command[@]:2}" )
rest_opt=( "${parse_command[@]:3}" )

check_var(){
	echo main_opt=${main_opt}
	echo sub_opt=${sub_opt}
	echo named=${named}
	echo named_in_opt=${named_in_opt[@]}
	echo rest_opt=${rest_opt[@]}
}
#check_var

parse_create(){
		
	if [[ -z "${named}" ]]; then
		out_error "Name must not be empty"
		usage
		exit 1
	fi
	
	case "${sub_opt}" in
		c|create)
			create "${named}" "${rest_opt[@]}"
			;;
		*)
			usage
			exit 1
			;;
	esac

}

parse_build(){
		
	if [[ -z "${named}" ]]; then
		out_error "Name must not be empty"
		usage
		exit 1
	fi
	
	case "${sub_opt}" in
		b|build)
			build "${named}" 0 "${rest_opt[@]}"
			;;
		r|remake)
			remake "${named}" 0 "${rest_opt[@]}"
			;;
		s|snap)
			build "${named}" 1 "${rest_opt[@]}"
			;;
		*)
			usage
			exit 1
			;;
	esac

}

parse_manage(){
		
	case "${sub_opt}" in
		n|network)	
			manage_network
			;;
		# Allow one character selection for other command
		*)	
			manage "${sub_opt}" #special case here, $sub_opt replace $named
			;;
	esac
	
}

case "${main_opt}" in
	C|Create)
		parse_create 
	    ;;
	B|Build)	
		parse_build 
		;;
	M|Manage)
		parse_manage 
		;;
	*)
	    usage
	    exit 1
	    ;;
esac

exit 0
