#!/usr/bin/bash
#
#
# Main sript of obarun-build package
#
# Authors:
# Eric Vidal <eric@obarun.org>
#
# Copyright (C) 2016 Eric Vidal <eric@obarun.org>
#
# "THE BEERWARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal http://obarun.org
#
# This script is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 

##		Check is the functions file exits

sourcing(){
	
	local list
	
	for list in /usr/lib/obarun/{common_functions,build_functions} /etc/obarun/build.conf; do
		if [[ -f "${list}" ]]; then
			source "${list}"
		else
			echo_error " Missing file : ${list}"
			exit	
		fi
	done
	
	unset list
}
sourcing

shellopts_save
shellopts_set_unset "extglob" 0

##		Clean before exit

trap "clean_install" ERR QUIT KILL STOP INT TERM 

##		Must be run without root privilegies 

(( EUID == 0 )) || die " ${bred}You must be run this script with root privilegies" "clean_install"

##		Let's go

##		Update package or not

main_update(){
	echo_display " Do you want to update obarun-build package? [y|n]"

	reply_answer

	if (( ! $? )); then
		pac_update "obarun-build" "/var/lib/obarun/obarun-build" "$GIT_ADDR" || die " Impossible to update" "clean_install"
		source /usr/lib/obarun/build_functions
	else
		echo_retry " Some functionalities will cannot working properly without updating"
		echo_info " Press enter to continue"
		read enter
	fi
}

if [[ "$UPDATE" == "yes" ]]; then
	main_update
fi

if [[ -z "${1}" || -z "${2}" ]] && [[ "${1}" != @(M|Manage) ]]; then
	usage
	exit 1
fi

parse_command=( "${@}" )
main_opt=( "${parse_command[0]}" )
sub_opt=( "${parse_command[1]}" )
named=( "${parse_command[2]}" )
named_in_opt=( "${parse_command[@]:2}" )
rest_opt=( "${parse_command[@]:3}" )

check_var(){
	echo main_opt=${main_opt}
	echo sub_opt=${sub_opt}
	echo named=${named}
	echo named_in_opt=${named_in_opt[@]}
	echo rest_opt=${rest_opt[@]}
}
#check_var

parse_create(){
		
	if [[ -z "${named}" ]]; then
		echo_error " Name must not be empty"
		usage
		exit 1
	fi
	
	case "${sub_opt}" in
		c|create)
			create "${named}" "${rest_opt[@]}"
			;;
		*)
			usage
			exit 1
			;;
	esac

}

parse_build(){
		
	if [[ -z "${named}" ]]; then
		echo_error " Name must not be empty"
		usage
		exit 1
	fi
	
	case "${sub_opt}" in
		b|build)
		echo 
			build "${named}" "${rest_opt[@]}"
			;;
		r|remake)
			remake "${named}" "${rest_opt[@]}"
			;;
		*)
			usage
			exit 1
			;;
	esac

}

parse_manage(){
		
	case "${sub_opt}" in
		n|network)	
			manage_network
			;;
		# Allow one character selection for other command
		*)	
			manage "${sub_opt}" #special case here, $sub_opt replace $named
			;;
	esac
	
}

case "${main_opt}" in
	C|Create)
		parse_create 
	    ;;
	B|Build)	
		parse_build 
		;;
	M|Manage)
		parse_manage 
		;;
	*)
	    usage
	    exit 1
	    ;;
esac

exit 0
